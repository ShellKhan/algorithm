# Задание 1.
# Проанализировать скорость и сложность алгоритма из задания 3.7.
# Выбрать лучший из нескольких вариантов решения.

import random
import timeit

SIZE = 1000
MIN_ITEM = -100
MAX_ITEM = 100
TIMEIT_COUNT = 10000


# 1. Мое решение - через заведомо большие значения float(Inf)
def two_less_1(mylist: list) -> tuple:
    minimal = float('inf')
    subminimal = float('inf')
    for i in mylist:
        if i < minimal:
            subminimal = minimal
            minimal = i
        elif i < subminimal:
            subminimal = i
    return minimal, subminimal


# 2. Решение преподавателя - через первые два значения массива, в индексах
def two_less_2(mylist: list) -> tuple:
    minimal, subminimal = (0, 1) if mylist[0] < mylist[1] else (1, 0)
    for i in range(2, len(mylist)):
        if mylist[i] < mylist[minimal]:
            spam = minimal
            minimal = i
            if mylist[spam] < mylist[subminimal]:
                subminimal = spam
        elif mylist[i] < mylist[subminimal]:
            subminimal = i
    return mylist[minimal], mylist[subminimal]


# 3. Решение преподавателя с заменой индексов на значения (устраняем влияние использования индексов)
def two_less_3(mylist: list) -> tuple:
    minimal, subminimal = (mylist[0], mylist[1]) if mylist[0] < mylist[1] else (mylist[1], mylist[0])
    for i in range(2, len(mylist)):
        if mylist[i] < minimal:
            spam = minimal
            minimal = mylist[i]
            if spam < subminimal:
                subminimal = spam
        elif mylist[i] < subminimal:
            subminimal = mylist[i]
    return minimal, subminimal


# 4. Решение без присвоения начального значения (проверяем влияние дополнительного ветвления алгоритма)
def two_less_4(mylist: list) -> tuple:
    minimal = None
    subminimal = None
    for i in mylist:
        if not minimal:
            minimal = i
        elif not subminimal:
            if i > minimal:
                subminimal = i
            else:
                subminimal = minimal
                minimal = i
        elif i < minimal:
            spam = minimal
            minimal = i
            if spam < subminimal:
                subminimal = spam
        elif i < subminimal:
            subminimal = i
    return minimal, subminimal


array = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE)]
print(array)
print(timeit.timeit('two_less_1(array)', number=TIMEIT_COUNT, globals=globals()))
print(timeit.timeit('two_less_2(array)', number=TIMEIT_COUNT, globals=globals()))
print(timeit.timeit('two_less_3(array)', number=TIMEIT_COUNT, globals=globals()))
print(timeit.timeit('two_less_4(array)', number=TIMEIT_COUNT, globals=globals()))

"""
В качестве n используется значение SIZE - длина генерируемого массива.
Проверялись n из набора [10, 25, 50, 100, 250, 500, 1000].
Число повторов TIMEIT_COUNT, как рекомендовано в документации, 10000.
Проверка выполняется для каждого n на 10 случайным образом сгенерированных массивах.
Результаты проверок усреднены и округлены до 7 знака (поскольку обычно результат имеет как раз 7 знаков после запятой).
Полные результаты, обработка и графики - в приложенном экселевском файле (лист "Задача 1").
n = 10:
    0,0304118
    0,0245397
    0,0197078
    0,0221169
n = 25:
    0,0390124
    0,0467844
    0,0397386
    0,0374367
n = 50:
    0,0603000
    0,0865511
    0,0713476
    0,0745606
n = 100:
    0,1015351
    0,1610875
    0,1165420
    0,1347038
n = 250:
    0,2176640
    0,3906511
    0,2922376
    0,3363573
n = 500:
    0,4122712
    0,8374394
    0,6201303
    0,6519640
n = 1000:
    0,7773288
    1,6627869
    1,3634970
    1,2781362
Сложность алгоритма для всех вариантов оценивается как линейная (цикл делает один проход по массиву), что подтверждается
построенным на основании полученных результатов графиком - линии зависимостей практически прямые (для иллюстрации было
бы неплохо построить график "с усами", но эксель этого не умеет, а других программ для построения графиков сейчас нет
под рукой).
Из результатов видно, что первый вариант оказывается наиболее быстрым на массивах с 50 и более элементов -
и чем больше массив, тем больше выигрыш.
На массивах меньше 50 элементов наиболее быстрыми оказываются варианты 3 и 4. При этом вариант 4 лучше только при n = 25
и n = 1000, а в остальных случаях устойчивое превосходство у варианта 3. Из чего можно предположить, что превосходство
варианта 4 вызвано только статистическими флуктуациями. Но это предположение требует дополнительных исследований с
большим числом вариантов n и большим набором повторностей.  
Вариант 2 для всех случаев, кроме n = 10, дает наихудший результат.
Выводы:
    1) перебор вариантов ветвления требует времени, изначально небольшого - но на многих итерациях оно накапливается;
    2) извлечение значений через индексы также требует дополнительного времени, которое также склонно накапливаться на
    многих итерациях, при этом играет роль и количество операций по извлечению значения по индексу - каждое упоминание
    элемента по индексу дополнительно ухудшает общий показатель;
    3) таким образом в зависимости от конкретного количества ветвлений и извлечений значения по индексу в одной итерации
    преимущество может получать как вариант с индексами, так и вариант с ветвлениями;
    3) генерация для присвоения особых значений типа float('inf') требует заметно большего времени, чем присвоение None
    или значения из массива (даже с учетом его извлечения по индексу). На малых n выигрыш за счет меньшего количества
    ветвлений и отсутствия операций с индексами не помогает исправить ситуацию. Но с увеличением n выигрыш за счет
    отсутствия потерь времени внутри итерации становится все более заметным, и примерно после n = 25 вариант с
    использованием заведомо больших значений становится наилучшим.  
"""
